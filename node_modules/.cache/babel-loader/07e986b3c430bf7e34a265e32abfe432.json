{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { CancelledError, Console, functionalUpdate, isCancelable, isCancelledError, isDocumentVisible, isOnline, isServer, isValidTimeout, noop, replaceEqualDeep, sleep } from './utils';\nimport { QueryStatus } from './types';\nimport { QueryObserver } from './queryObserver';\nimport { notifyManager } from './notifyManager'; // TYPES\n\nfunction _empty() {}\n\nvar ActionType = {\n  Failed: 0,\n  Fetch: 1,\n  Success: 2,\n  Error: 3,\n  Invalidate: 4\n}; // CLASS\n\nfunction _awaitIgnored(value, direct) {\n  if (!direct) {\n    return value && value.then ? value.then(_empty) : Promise.resolve();\n  }\n}\n\nfunction _invoke(body, then) {\n  var result = body();\n\n  if (result && result.then) {\n    return result.then(then);\n  }\n\n  return then(result);\n}\n\nfunction _await(value, then, direct) {\n  if (direct) {\n    return then ? then(value) : value;\n  }\n\n  if (!value || !value.then) {\n    value = Promise.resolve(value);\n  }\n\n  return then ? value.then(then) : value;\n}\n\nfunction _catch(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nfunction _async(f) {\n  return function () {\n    for (var args = [], i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    try {\n      return Promise.resolve(f.apply(this, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n\nexport var Query = /*#__PURE__*/function () {\n  function Query(config) {\n    this.config = config;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.queryCache = config.queryCache;\n    this.cacheTime = config.cacheTime;\n    this.observers = [];\n    this.state = getDefaultState(config);\n    this.scheduleGc();\n  }\n\n  var _proto = Query.prototype;\n\n  _proto.updateConfig = function updateConfig(config) {\n    this.config = config;\n    this.cacheTime = Math.max(this.cacheTime, config.cacheTime);\n  };\n\n  _proto.dispatch = function dispatch(action) {\n    var _this = this;\n\n    this.state = queryReducer(this.state, action);\n    notifyManager.batch(function () {\n      _this.observers.forEach(function (observer) {\n        observer.onQueryUpdate(action);\n      });\n\n      _this.queryCache.notifyGlobalListeners(_this);\n    });\n  };\n\n  _proto.scheduleGc = function scheduleGc() {\n    var _this2 = this;\n\n    if (isServer) {\n      return;\n    }\n\n    this.clearGcTimeout();\n\n    if (this.observers.length > 0 || !isValidTimeout(this.cacheTime)) {\n      return;\n    }\n\n    this.gcTimeout = setTimeout(function () {\n      _this2.remove();\n    }, this.cacheTime);\n  };\n\n  _proto.cancel = function cancel(silent) {\n    var promise = this.promise;\n\n    if (promise && this.cancelFetch) {\n      this.cancelFetch(silent);\n      return promise.then(noop).catch(noop);\n    }\n\n    return Promise.resolve(undefined);\n  };\n\n  _proto.continue = function _continue() {\n    var _this$continueFetch;\n\n    (_this$continueFetch = this.continueFetch) == null ? void 0 : _this$continueFetch.call(this);\n  };\n\n  _proto.clearTimersObservers = function clearTimersObservers() {\n    this.observers.forEach(function (observer) {\n      observer.clearTimers();\n    });\n  };\n\n  _proto.clearGcTimeout = function clearGcTimeout() {\n    if (this.gcTimeout) {\n      clearTimeout(this.gcTimeout);\n      this.gcTimeout = undefined;\n    }\n  };\n\n  _proto.setData = function setData(updater, options) {\n    var _this$config$isDataEq, _this$config;\n\n    var prevData = this.state.data; // Get the new data\n\n    var data = functionalUpdate(updater, prevData); // Structurally share data between prev and new data if needed\n\n    if (this.config.structuralSharing) {\n      data = replaceEqualDeep(prevData, data);\n    } // Use prev data if an isDataEqual function is defined and returns `true`\n\n\n    if ((_this$config$isDataEq = (_this$config = this.config).isDataEqual) == null ? void 0 : _this$config$isDataEq.call(_this$config, prevData, data)) {\n      data = prevData;\n    } // Try to determine if more data can be fetched\n\n\n    var canFetchMore = hasMorePages(this.config, data); // Set data and mark it as cached\n\n    this.dispatch({\n      type: ActionType.Success,\n      data: data,\n      canFetchMore: canFetchMore,\n      updatedAt: options == null ? void 0 : options.updatedAt\n    });\n  }\n  /**\n   * @deprecated\n   */\n  ;\n\n  _proto.clear = function clear() {\n    Console.warn('react-query: clear() has been deprecated, please use remove() instead');\n    this.remove();\n  };\n\n  _proto.remove = function remove() {\n    this.queryCache.removeQuery(this);\n  };\n\n  _proto.destroy = function destroy() {\n    this.clearGcTimeout();\n    this.clearTimersObservers();\n    this.cancel();\n  };\n\n  _proto.isActive = function isActive() {\n    return this.observers.some(function (observer) {\n      return observer.config.enabled;\n    });\n  };\n\n  _proto.isStale = function isStale() {\n    return this.state.isInvalidated || this.state.status !== QueryStatus.Success || this.observers.some(function (observer) {\n      return observer.getCurrentResult().isStale;\n    });\n  };\n\n  _proto.isStaleByTime = function isStaleByTime(staleTime) {\n    if (staleTime === void 0) {\n      staleTime = 0;\n    }\n\n    return this.state.isInvalidated || this.state.status !== QueryStatus.Success || this.state.updatedAt + staleTime <= Date.now();\n  };\n\n  _proto.onInteraction = function onInteraction(type) {\n    // Execute the first observer which is enabled,\n    // stale and wants to refetch on this interaction.\n    var staleObserver = this.observers.find(function (observer) {\n      var config = observer.config;\n\n      var _observer$getCurrentR = observer.getCurrentResult(),\n          isStale = _observer$getCurrentR.isStale;\n\n      return config.enabled && (type === 'focus' && (config.refetchOnWindowFocus === 'always' || config.refetchOnWindowFocus && isStale) || type === 'online' && (config.refetchOnReconnect === 'always' || config.refetchOnReconnect && isStale));\n    });\n\n    if (staleObserver) {\n      staleObserver.fetch();\n    } // Continue any paused fetch\n\n\n    this.continue();\n  }\n  /**\n   * @deprectated\n   */\n  ;\n\n  _proto.subscribe = function subscribe(listener) {\n    var observer = new QueryObserver(this.config);\n    observer.subscribe(listener);\n    return observer;\n  };\n\n  _proto.subscribeObserver = function subscribeObserver(observer) {\n    this.observers.push(observer); // Stop the query from being garbage collected\n\n    this.clearGcTimeout();\n  };\n\n  _proto.unsubscribeObserver = function unsubscribeObserver(observer) {\n    this.observers = this.observers.filter(function (x) {\n      return x !== observer;\n    });\n\n    if (!this.observers.length) {\n      // If the transport layer does not support cancellation\n      // we'll let the query continue so the result can be cached\n      if (this.isTransportCancelable) {\n        this.cancel();\n      }\n\n      this.scheduleGc();\n    }\n  };\n\n  _proto.invalidate = function invalidate() {\n    if (!this.state.isInvalidated) {\n      this.dispatch({\n        type: ActionType.Invalidate\n      });\n    }\n  }\n  /**\n   * @deprectated\n   */\n  ;\n\n  _proto.refetch = function refetch(options, config) {\n    var promise = this.fetch(undefined, config);\n\n    if (!(options == null ? void 0 : options.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n  /**\n   * @deprectated\n   */\n  ;\n\n  _proto.fetchMore = function fetchMore(fetchMoreVariable, options, config) {\n    return this.fetch({\n      fetchMore: {\n        fetchMoreVariable: fetchMoreVariable,\n        previous: (options == null ? void 0 : options.previous) || false\n      }\n    }, config);\n  };\n\n  _proto.fetch = function fetch(options, config) {\n    try {\n      var _exit2 = false;\n\n      var _this4 = this;\n\n      return _invoke(function () {\n        if (_this4.promise) {\n          return function () {\n            if ((options == null ? void 0 : options.fetchMore) && _this4.state.data) {\n              // Silently cancel current fetch if the user wants to fetch more\n              return _awaitIgnored(_this4.cancel(true));\n            } else {\n              // Return current promise if we are already fetching\n              _exit2 = true;\n              return _this4.promise;\n            }\n          }();\n        }\n      }, function (_result2) {\n        if (_exit2) return _result2; // Update config if passed, otherwise the config from the last execution is used\n\n        if (config) {\n          _this4.updateConfig(config);\n        }\n\n        config = _this4.config; // Get the query function params\n\n        var filter = config.queryFnParamsFilter;\n        var params = filter ? filter(_this4.queryKey) : _this4.queryKey;\n        _this4.promise = _async(function () {\n          return _catch(function () {\n            var data;\n            return _invoke(function () {\n              if (config.infinite) {\n                return _await(_this4.startInfiniteFetch(config, params, options), function (_this4$startInfiniteF) {\n                  data = _this4$startInfiniteF;\n                });\n              } else {\n                return _await(_this4.startFetch(config, params, options), function (_this4$startFetch) {\n                  data = _this4$startFetch;\n                });\n              }\n            }, function () {\n              // Set success state\n              _this4.setData(data); // Cleanup\n\n\n              delete _this4.promise; // Return data\n\n              return data;\n            });\n          }, function (error) {\n            // Set error state if needed\n            if (!(isCancelledError(error) && error.silent)) {\n              _this4.dispatch({\n                type: ActionType.Error,\n                error: error\n              });\n            } // Log error\n\n\n            if (!isCancelledError(error)) {\n              Console.error(error);\n            } // Cleanup\n\n\n            delete _this4.promise; // Propagate error\n\n            throw error;\n          });\n        })();\n        return _this4.promise;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.startFetch = function startFetch(config, params, _options) {\n    // Create function to fetch the data\n    var fetchData = function fetchData() {\n      return config.queryFn.apply(config, params);\n    }; // Set to fetching state if not already in it\n\n\n    if (!this.state.isFetching) {\n      this.dispatch({\n        type: ActionType.Fetch\n      });\n    } // Try to fetch the data\n\n\n    return this.tryFetchData(config, fetchData);\n  };\n\n  _proto.startInfiniteFetch = function startInfiniteFetch(config, params, options) {\n    var fetchMore = options == null ? void 0 : options.fetchMore;\n\n    var _ref = fetchMore || {},\n        previous = _ref.previous,\n        fetchMoreVariable = _ref.fetchMoreVariable;\n\n    var isFetchingMore = fetchMore ? previous ? 'previous' : 'next' : false;\n    var prevPages = this.state.data || []; // Create function to fetch a page\n\n    var fetchPage = _async(function (pages, prepend, cursor) {\n      var lastPage = getLastPage(pages, prepend);\n\n      if (typeof cursor === 'undefined' && typeof lastPage !== 'undefined' && config.getFetchMore) {\n        cursor = config.getFetchMore(lastPage, pages);\n      }\n\n      return !Boolean(cursor) && typeof lastPage !== 'undefined' ? pages : _await(config.queryFn.apply(config, params.concat([cursor])), function (page) {\n        return prepend ? [page].concat(pages) : [].concat(pages, [page]);\n      });\n    }); // Create function to fetch the data\n\n\n    var fetchData = function fetchData() {\n      if (isFetchingMore) {\n        return fetchPage(prevPages, previous, fetchMoreVariable);\n      } else if (!prevPages.length) {\n        return fetchPage([]);\n      } else {\n        var promise = fetchPage([]);\n\n        for (var i = 1; i < prevPages.length; i++) {\n          promise = promise.then(fetchPage);\n        }\n\n        return promise;\n      }\n    }; // Set to fetching state if not already in it\n\n\n    if (!this.state.isFetching || this.state.isFetchingMore !== isFetchingMore) {\n      this.dispatch({\n        type: ActionType.Fetch,\n        isFetchingMore: isFetchingMore\n      });\n    } // Try to get the data\n\n\n    return this.tryFetchData(config, fetchData);\n  };\n\n  _proto.tryFetchData = function tryFetchData(config, fn) {\n    var _this5 = this;\n\n    return new Promise(function (outerResolve, outerReject) {\n      var resolved = false;\n      var continueLoop;\n      var cancelTransport;\n\n      var done = function done() {\n        resolved = true;\n        delete _this5.cancelFetch;\n        delete _this5.continueFetch;\n        delete _this5.isTransportCancelable; // End loop if currently paused\n\n        continueLoop == null ? void 0 : continueLoop();\n      };\n\n      var resolve = function resolve(value) {\n        done();\n        outerResolve(value);\n      };\n\n      var reject = function reject(value) {\n        done();\n        outerReject(value);\n      }; // Create callback to cancel this fetch\n\n\n      _this5.cancelFetch = function (silent) {\n        reject(new CancelledError(silent));\n        cancelTransport == null ? void 0 : cancelTransport();\n      }; // Create callback to continue this fetch\n\n\n      _this5.continueFetch = function () {\n        continueLoop == null ? void 0 : continueLoop();\n      }; // Create loop function\n\n\n      var run = _async(function () {\n        return _catch(function () {\n          // Execute query\n          var promiseOrValue = fn(); // Check if the transport layer support cancellation\n\n          if (isCancelable(promiseOrValue)) {\n            cancelTransport = function cancelTransport() {\n              try {\n                promiseOrValue.cancel();\n              } catch (_unused) {}\n            };\n\n            _this5.isTransportCancelable = true;\n          } // Await data\n\n\n          return _await(promiseOrValue, function (_promiseOrValue) {\n            resolve(_promiseOrValue);\n          });\n        }, function (error) {\n          // Stop if the fetch is already resolved\n          if (resolved) {\n            return;\n          } // Do we need to retry the request?\n\n\n          var failureCount = _this5.state.failureCount;\n          var retry = config.retry,\n              retryDelay = config.retryDelay;\n          var shouldRetry = retry === true || failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n\n          if (!shouldRetry) {\n            // We are done if the query does not need to be retried\n            reject(error);\n            return;\n          } // Increase the failureCount\n\n\n          _this5.dispatch({\n            type: ActionType.Failed\n          }); // Delay\n\n\n          return _await(sleep(functionalUpdate(retryDelay, failureCount) || 0), function () {\n            // Pause retry if the document is not visible or when the device is offline\n            return _invoke(function () {\n              if (!isDocumentVisible() || !isOnline()) {\n                return _awaitIgnored(new Promise(function (continueResolve) {\n                  continueLoop = continueResolve;\n                }));\n              }\n            }, function () {\n              if (!resolved) {\n                run();\n              }\n            }); // Try again if not resolved yet\n          });\n        });\n      }); // Start loop\n\n\n      run();\n    });\n  };\n\n  return Query;\n}();\n\nfunction getLastPage(pages, previous) {\n  return previous ? pages[0] : pages[pages.length - 1];\n}\n\nfunction hasMorePages(config, pages, previous) {\n  if (config.infinite && config.getFetchMore && Array.isArray(pages)) {\n    return Boolean(config.getFetchMore(getLastPage(pages, previous), pages));\n  }\n}\n\nfunction getDefaultState(config) {\n  var data = typeof config.initialData === 'function' ? config.initialData() : config.initialData;\n  var status = typeof data !== 'undefined' ? QueryStatus.Success : config.enabled ? QueryStatus.Loading : QueryStatus.Idle;\n  return {\n    canFetchMore: hasMorePages(config, data),\n    data: data,\n    error: null,\n    failureCount: 0,\n    isFetching: status === QueryStatus.Loading,\n    isFetchingMore: false,\n    isInitialData: true,\n    isInvalidated: false,\n    status: status,\n    updateCount: 0,\n    updatedAt: Date.now()\n  };\n}\n\nexport function queryReducer(state, action) {\n  var _action$updatedAt;\n\n  switch (action.type) {\n    case ActionType.Failed:\n      return _extends({}, state, {\n        failureCount: state.failureCount + 1\n      });\n\n    case ActionType.Fetch:\n      return _extends({}, state, {\n        failureCount: 0,\n        isFetching: true,\n        isFetchingMore: action.isFetchingMore || false,\n        status: typeof state.data !== 'undefined' ? QueryStatus.Success : QueryStatus.Loading\n      });\n\n    case ActionType.Success:\n      return _extends({}, state, {\n        canFetchMore: action.canFetchMore,\n        data: action.data,\n        error: null,\n        failureCount: 0,\n        isFetching: false,\n        isFetchingMore: false,\n        isInitialData: false,\n        isInvalidated: false,\n        status: QueryStatus.Success,\n        updateCount: state.updateCount + 1,\n        updatedAt: (_action$updatedAt = action.updatedAt) != null ? _action$updatedAt : Date.now()\n      });\n\n    case ActionType.Error:\n      return _extends({}, state, {\n        error: action.error,\n        failureCount: state.failureCount + 1,\n        isFetching: false,\n        isFetchingMore: false,\n        status: QueryStatus.Error,\n        throwInErrorBoundary: true,\n        updateCount: state.updateCount + 1\n      });\n\n    case ActionType.Invalidate:\n      return _extends({}, state, {\n        isInvalidated: true\n      });\n\n    default:\n      return state;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}